


local player = game.Players.LocalPlayer
	local char = player.Character
	local Humanoid = char.Humanoid
	local hot = player.PlayerGui:WaitForChild("Hotbar")
	local hotbar = hot:WaitForChild("Backpack"):WaitForChild("Hotbar")

	local function cloneToolName(slot, text)
		local toolName = slot.ToolName
		if not slot:FindFirstChild("CustomName") then
			toolName.Visible = false
			local clone = toolName:Clone()
			clone.Name = "CustomName"
			clone.Parent = slot
			clone.Text = text
			clone.Visible = true
		elseif slot:FindFirstChild("CustomName") then
			if slot:FindFirstChild("CustomName").Text ~= text then
				toolName.Visible = false
				slot:FindFirstChild("CustomName").Text = text
			end
		end
	end

	local magichealth = player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("MagicHealth")
	local UltLabel = magichealth:WaitForChild("TextLabel")
	UltLabel.Visible = false
	local UltLabel = UltLabel:Clone()
	UltLabel.Visible = true
	UltLabel.Name = "UltThing"
	UltLabel.Parent = magichealth

	local toolNameMap = {
		["Bullet Barrage"] = "Dimensional Entrapment",
		["Vanishing Kick"] = "Teleportation Kick",
		["Whirlwind Drop"] = "Portal Drop",
		["Head First"] = "Dimensional Drop",
		["Water Stream Cutting Fist"] = "?",
		["The Final Hunt"] = "?",
		["Rock Splitting Fist"] = "?",
		["Crushed Rock"] = "?"
	}

	local function typeText(label, text, delay)
		delay = delay or 0.05
		local originalText = text
		label.Text = ""
		for i = 1, #originalText do
			label.Text = string.sub(originalText, 1, i)
			task.wait(delay)
		end
	end
	local ultTexts = {
		"I WON'T BUILD MY UTOPIA WITH BLOOD!‚Äù"
		
	}


	local typedTools = {}

	local function updateToolNames()
		for _, slot in ipairs(hotbar:GetChildren()) do
			if slot:FindFirstChild("Base") and slot.Base:FindFirstChild("ToolName") then
				local toolNameText = slot.Base.ToolName.Text
				local newName = toolNameMap[toolNameText]
				if newName then
					cloneToolName(slot.Base, newName)
					if slot.Base:FindFirstChild("CustomName") and not typedTools[newName] then
						typeText(slot.Base.CustomName, newName, 0.03)
						typedTools[newName] = true


					end
				end
			end
		end
	end

	task.spawn(
		function()
			local currentUltIndex = 1

			while true do
				typeText(UltLabel, ultTexts[currentUltIndex], 0.05)
				currentUltIndex = (currentUltIndex % #ultTexts) + 1

				pcall(
					function()
					end
				)

				updateToolNames()
				task.wait(10)
			end
		end
	)

	task.spawn(
		function()
			while task.wait(1) do
				updateToolNames()
			end
		end
	)

-- GUI Setup
local player = game.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 260, 0, 170) -- Adjusted for 3 buttons
frame.Position = UDim2.new(0, 10, 0.5, -75) -- Moved to the left side
frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
frame.Parent = screenGui

-- Create teleport buttons
local locations = {
    {name = "Spot 1 (VOID)", position = Vector3.new(-2229.283447265625, 4282.67529296875, -21043.578125)},
    {name = "Spot 2 (CENTRE)", position = Vector3.new(146.4515838623047, 440.7559814453125, 23.027311325073242)},
    {name = "Spot 3 (CLIFF)", position = Vector3.new(325.9632568359375, 701.2406616210938, 446.8995056152344)},
	{name = "Spot 4 (ONLY VS INVINCIBLE MOON)", position = Vector3.new(10200, 5.5, 9900)},
	{name = "Spot 5 (ONLY VS INVINCIBLE DESERT)", position = Vector3.new(10200, 5.5, 9900)},
	{name = "Spot 6 (PRIVATE DIMENSION)", position = Vector3.new(10200, 5.5, 9900)},
	
}

local selectedLocation = locations[1].position -- Default teleport location

local function createButton(text, index, teleportPosition)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, 0, 0, 30)
    button.Position = UDim2.new(0, 0, 0, (index - 1) * 30) -- Ensure correct stacking
    button.Text = text
    button.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    button.Parent = frame
    
    button.MouseButton1Click:Connect(function()
        selectedLocation = teleportPosition
    end)
end

for i, location in ipairs(locations) do
    print("Creating button for:", location.name) -- Debugging
    createButton(location.name, i, location.position)
end

-- Detect animation and teleport
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

local function teleportToLocation(delayTime)
    if rootPart then
        local previousPosition = rootPart.CFrame -- Store previous position
        
        -- Wait for the given delay time before teleporting
        task.wait(delayTime)
        
        rootPart.CFrame = CFrame.new(selectedLocation) -- Teleport to selected location
        
        -- Wait 2.9 seconds then teleport back
        task.delay(2.9, function()
            rootPart.CFrame = previousPosition
        end)
    end
end

local function onAnimationPlayed(animationTrack)
    local animationId = animationTrack.Animation.AnimationId
    
    -- Check for the first animation ID (teleport after 2 seconds)
    if animationId == "rbxassetid://17799224866" then
        teleportToLocation(2) -- Wait 2 seconds before teleporting
    -- Check for the second animation ID (teleport after 1 second)
    elseif animationId == "rbxassetid://18182425133" then
        teleportToLocation(1) -- Wait 1 second before teleporting
    end
end

humanoid.AnimationPlayed:Connect(onAnimationPlayed)




local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local meshID = "rbxassetid://9331634848"

-- Adjust this to move the first mesh (X, Y, Z)
local offsetPosition1 = Vector3.new(0, 25, 15) -- X = left/right, Y = up/down, Z = forward/back

-- Adjust this to move the second mesh (X, Y, Z)
local offsetPosition2 = Vector3.new(0, 55, 0) -- Modify these values as needed

local targetAnimationID = "rbxassetid://18182425133"

local function createMesh(offset)
    -- Get the player's forward direction
    local forwardDirection = humanoidRootPart.CFrame.LookVector
    
    -- Calculate the new position based on the direction the player is facing
    local meshPosition = humanoidRootPart.Position + (forwardDirection * offset.Z) + Vector3.new(offset.X, offset.Y, 0)
    
    -- Create the part that will hold the mesh
    local meshPart = Instance.new("Part")
    meshPart.Size = Vector3.new(1, 1, 1) -- Keep it small since mesh scaling handles size
    meshPart.Position = meshPosition
    meshPart.Anchored = true
    meshPart.CanCollide = false
    meshPart.CastShadow = false -- Disable shadows
    meshPart.Parent = workspace

    -- Change the color to green
    meshPart.BrickColor = BrickColor.new("Bright green")

    -- Create and set the mesh on the part
    local mesh = Instance.new("SpecialMesh")
    mesh.MeshId = meshID
    mesh.Scale = Vector3.new(5, 5, 5) -- Set the size of the mesh
    mesh.Parent = meshPart

    -- Ensure the mesh faces up (rotate 90 degrees along the X-axis)
    meshPart.CFrame = CFrame.new(meshPosition, meshPosition + forwardDirection) * CFrame.Angles(math.rad(90), 0, 0)

    -- Make the mesh disappear after 5 seconds
    task.delay(5, function()
        if meshPart then
            meshPart:Destroy()
        end
    end)
end

-- Detect animation playing
local function onAnimationPlayed(track)
    if track.Animation and track.Animation.AnimationId == targetAnimationID then
        createMesh(offsetPosition1)

        -- Spawn another identical mesh after 2.7 seconds
        task.delay(1.4, function()
            createMesh(offsetPosition2)
        end)
    end
end

-- Listen for animations playing
humanoid.Animator.AnimationPlayed:Connect(onAnimationPlayed)





-----BULLET BARRAGE
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local meshID = "rbxassetid://9331634848"

-- Adjust this to move the first mesh (X, Y, Z)
local offsetPosition1 = Vector3.new(0, 15, 20) -- X = left/right, Y = up/down, Z = forward/back

-- Adjust this to move the second mesh (X, Y, Z)
local offsetPosition2 = Vector3.new(0, -410, 0) -- Modify these values as needed

local targetAnimationID = "rbxassetid://17799224866"

local function createMesh(offset, shouldFaceUp)
    -- Get the player's forward direction
    local forwardDirection = humanoidRootPart.CFrame.LookVector
    
    -- Calculate the new position based on the direction the player is facing
    local meshPosition = humanoidRootPart.Position + (forwardDirection * offset.Z) + Vector3.new(offset.X, offset.Y, 0)
    
    -- Create the part that will hold the mesh
    local meshPart = Instance.new("Part")
    meshPart.Size = Vector3.new(1, 1, 1) -- Keep it small since mesh scaling handles size
    meshPart.Position = meshPosition
    meshPart.Anchored = true
    meshPart.CanCollide = false
    meshPart.CastShadow = false -- Disable shadows
    meshPart.Parent = workspace

    -- Change the color to green
    meshPart.BrickColor = BrickColor.new("Bright green")

    -- Create and set the mesh on the part
    local mesh = Instance.new("SpecialMesh")
    mesh.MeshId = meshID
    mesh.Scale = Vector3.new(5, 5, 5) -- Set the size of the mesh
    mesh.Parent = meshPart

    -- Adjust the rotation
    if shouldFaceUp then
        -- Make it face directly up
        meshPart.CFrame = CFrame.new(meshPosition) * CFrame.Angles(math.rad(-90), 0, 0)
    else
        -- Keep the original forward-facing mesh
        meshPart.CFrame = CFrame.new(meshPosition, meshPosition + forwardDirection)
    end

    -- Make the mesh disappear after 5 seconds
    task.delay(5, function()
        if meshPart then
            meshPart:Destroy()
        end
    end)
end

-- Detect animation playing
local function onAnimationPlayed(track)
    if track.Animation and track.Animation.AnimationId == targetAnimationID then
        createMesh(offsetPosition1, false) -- First mesh faces forward

        -- Spawn another identical mesh after 2.4 seconds, facing up
        task.delay(2.4, function()
            createMesh(offsetPosition2, true) -- Second mesh faces up
        end)
    end
end

-- Listen for animations playing
humanoid.Animator.AnimationPlayed:Connect(onAnimationPlayed)
